package http

import (
	"net/http"
	"time"
)

/*
	- ReadTimeout
	Описание: Этот таймаут определяет максимальное время, в течение которого сервер будет ждать данных от клиента.
	Если клиент не отправляет данные в течение указанного времени, соединение закрывается.

	Рекомендация:
	- Значение может варьироваться от нескольких секунд до минуты, в зависимости от специфики вашего приложения.
	- Для веб-приложений, где ожидается, что запросы поступят быстро, разумный промежуток — 15-30 секунд.
	- Этот таймаут необходимо использовать, чтобы предотвратить блокировку сервера от долгоживущих соединений, которые могут исчерпать его ресурсы.

	- ReadHeaderTimeout
	Описание: Этот таймаут определяет, сколько времени сервер будет ждать, прежде чем завершит чтение заголовков от клиента.
	Он активен только на этапе установки соединения.

	Рекомендация:
	- Значение, как правило, должно быть меньше ReadTimeout, потому что это только часть цепочки ожидания данных.
	- Хорошее значение — 10-15 секунд. Это достаточный промежуток времени для большинства HTTP-заголовков, предоставляя защиту от медленных атак.

	- WriteTimeout
	Описание: Этот таймаут контролирует, сколько времени сервер будет блокировать операции записи в соединение.
	Если клиент не принимает данные, соединение будет закрыто.

	Рекомендация:
	- Обычно такое же значение, как и ReadTimeout или лишь немного меньше, в диапазоне 10-30 секунд.
	- Это помогает избежать ситуаций, когда сервер продолжает попытки отправить данные клиенту, который может быть недоступен или неактивен.
*/
const (
	ReadTimeout         = time.Second * 20
	ReadHeaderTimeout   = time.Second * 10
	WriteTimeout = time.Second * 20
)

type Server struct {
	server *http.Server
}

func NewServer(port string, handler http.Handler) *Server {
	return &Server{
		server: &http.Server{
			Addr:              ":" + port,
			Handler:           handler,
			ReadTimeout:       ReadTimeout,
			ReadHeaderTimeout: ReadHeaderTimeout,
			WriteTimeout: WriteTimeout,
		},
	}
}

func (s *Server) Start() {
	if err := s.server.ListenAndServe(); err != nil {
		panic(err)
	}
}
